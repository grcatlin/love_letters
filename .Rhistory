CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Bar Nunn", "Casper Mountain")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
View(cens)
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Bar Nunn", "Casper Mountain", "Midwest")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat)
cens
options(scipp)
options(scipen = 999)
cens
View(cens)
gc(full = T)
library(data.table)
library(stringr)
library(brms)
library(leaflet)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Bar Nunn", "Casper Mountain", "Midwest")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
cens
View(cens)
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
View(cens)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Bar Nunn", "Casper Mountain")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, stroke = F)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, opacity = .7)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, opacity = .5)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, opacity = .1)
?addCircleMarkers
# map
leaflet(cens) %>%
addTiles() %>%
addMarkers(~Est, lng = ~Lon, lat = ~Lat, opacity = .1)
addMarkers(~Est, lng = ~Lon, lat = ~Lat
# map
leaflet(cens) %>%
addTiles() %>%
addMarkers(~Est, lng = ~Lon, lat = ~Lat)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 3)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 10)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1)
View(cens)
library(htmlwidgets)
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1) %>%
saveWidget()
library(data.table)
library(stringr)
library(brms)
library(leaflet)
library(htmlwidgets)
library(data.table)
library(stringr)
library(brms)
library(leaflet)
library(htmlwidgets)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Bar Nunn", "Casper Mountain")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1) %>%
saveWidget()
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1) %>%
saveWidget("test")
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1) %>%
saveWidget("test.html")
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1)
View(cens)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Casper Mountain")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/100)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1)
leaflet(cens) %>%
addTiles() %>%
addCircleMarkers(~Est, lng = ~Lon, lat = ~Lat, weight = 1) %>%
saveWidget("test.html")
View(cens)
cens[, Act := Population/100]
View(cens)
View(cens)
# generate response variable
cens[, Response := rpois(.N, Population/50)]
# model
mod = brm(Response ~ Population,
data = cens,
family = poisson)
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
# generate estimates
cens[, Est := as.data.table(predict(mod, cens))$Estimate]
View(cens)
library(data.table)
library(stringr)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Casper Mountain")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
# generate response variable
cens[, Response := rpois(.N, Population/50)]
# library(brms)
library(leaflet)
# # model
# mod = brm(Response ~ Population,
#           data = cens,
#           family = poisson)
# pp_check(mod)
# pp_check(mod, type = "ecdf_overlay")
#
# # generate estimates
# cens[, Est := as.data.table(predict(mod, cens))$Estimate]
# map
leaflet(cens) %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircleMarkers(lng = ~Lon, lat = ~Lat, radius = 3,
stroke = F, fillOpacity = .4,
color = "#d0587e")
expand.grid(1:12)
# generate response variable
monthly = data.table()
for (month in 1:12) {
monthdat = cens[, MonthNo := month]
monthly = rbind(monthly, monthdat)
}
monthly
cens[!(MonthNo %in% c(1:2, 11:12)), Response := rpois(.N, Population/50)]
cens[MonthNo == 2, Response := rpois(.N, 3 * Population/50)]
cens[(MonthNo %in% c(1, 11:12)), Response := rpois(.N, Population/50)]
View(cens)
monthly[!(MonthNo %in% c(1:2, 11:12)), Response := rpois(.N, Population/50)]
monthly[MonthNo == 2, Response := rpois(.N, 3 * Population/50)]
monthly[(MonthNo %in% c(1, 11:12)), Response := rpois(.N, Population/50)]
View(monthly)
# generate response variable
monthly = data.table()
for (month in 1:12) {
monthdat = cens[, MonthNo := month]
monthly = rbind(monthly, monthdat)
}
monthly[!(MonthNo %in% c(1:2, 11:12)), Response := rpois(.N, Population/50)]
monthly[MonthNo == 2, Response := rpois(.N, 3 * Population/50)]
monthly[(MonthNo %in% c(1, 11:12)), Response := rpois(.N, 2 * Population/50)]
View(monthly)
monthly[, mean(Response), by = MonthNO]
monthly[, mean(Response), by = MonthNo]
monthly[, median(Response), by = MonthNo]
monthly[, mean(Response), by = MonthNo]
View(monthly)
head(monthly)
head(monthly)
cens[,MonthNo := NULL]
head(cens)
cens[, Response := NULL]
cens
monthly
monthly[, mean(Response), by = .(MonthNo, ID)]
monthly[, mean(Response), by =  ID]
cens
monthly[, mean(Response), by =  ID]
monthly[, mean(Response), by =  ID]$V1
cens = cbind(cend, monthly[, mean(Response), by =  ID]$V1)
cens = cbind(cens, monthly[, mean(Response), by =  ID]$V1)
cens
cens = cbind(cens, monthly[, mean(Response), by =  ID])
cens
library(data.table)
library(stringr)
cens = as.data.table(readRDS("R_Objects/cens_import.rds"))
cens = cens[, .(GEOCODE, POP100, INTPTLAT, INTPTLON, PLACE)]
cens[, INTPTLAT := gsub("\\+", "", INTPTLAT)] # get rid of "+" in latitude coordinates
cens = cens[str_length(GEOCODE) == 15] # filter to just census blocks
setkey(cens, PLACE)
# import names (https://www.census.gov/geographies/reference-files/time-series/geo/name-lookup-tables.html)
CDP_names = fread("cens_files/names/NAMES_ST56_WY_CDP.txt")
CITY_names = fread("cens_files/names/NAMES_ST56_WY_INCPLACE.txt")
names = rbind(CDP_names, CITY_names) # combine
names[, c("STATEFP", "NAMELSAD") := NULL] # remove more detailed name & state code
names[, PLACEFP := as.character(PLACEFP)]
setkey(names, PLACEFP)
# merge
cens = cens[names]
cens = cens[!(is.na(NAME))]
# filter to Casper Area
cens = cens[NAME %in% c("Casper", "Mills", "Evansville", "Casper Mountain")]
cens = cens[POP100 != 0]
length(cens$GEOCODE); length(unique(cens$GEOCODE)) # check to make sure each census block is unique
cens[, ID := 1:.N] # create ID variable (to replace GEOCODE)
cens[, c("NAME", "PLACE", "GEOCODE") := NULL] # remove unused cols after reduction
setnames(cens, c("Population", "Lat", "Lon", "ID")) # clean colnames
setcolorder(cens, "ID") # ID first
cens[, Population := as.numeric(Population)][, Lon := as.numeric(Lon)][, Lat := as.numeric(Lat)]
library(leaflet)
# map
leaflet(cens) %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircleMarkers(lng = ~Lon, lat = ~Lat, radius = 3,
stroke = F, fillOpacity = .4,
color = "#d0587e")
# generate response variable
monthly = data.table()
for (month in 1:12) {
monthdat = copy(cens)
monthdat = monthdat[, MonthNo := month]
monthly = rbind(monthly, monthdat)
}
monthly[!(MonthNo %in% c(1:2, 11:12)), Response := rpois(.N, Population/50)]
monthly[MonthNo == 2, Response := rpois(.N, 3 * Population/50)]
monthly[(MonthNo %in% c(1, 11:12)), Response := rpois(.N, 2 * Population/50)]
# check
monthly[, mean(Response), by = MonthNo]
cens = cbind(cens, monthly[, mean(Response), by =  ID]$V1)
cens
setnames(cens, "V2", "Avg_Call")
# map
leaflet(cens) %>%
addProviderTiles(providers$CartoDB.DarkMatter) %>%
addCircleMarkers(~Avg_Call, lng = ~Lon, lat = ~Lat,
stroke = F, fillOpacity = .4,
color = "#d0587e")
# save
saveRDS(monthly, "R_Objects/monthly.rds")
saveRDS(cens, "R_Objects/cens_cleaned.rds")
